<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=" id=&quot;ES6新特性-2015&quot;&gt;&lt;a href=&quot;#ES6新特性-2015&quot; class=&quot;headerlink&quot; title=&quot;ES6新特性(2015)&quot;&gt;&lt;/a&gt;ES6新特性(2015)&lt;/h3&gt;&lt;h4 id=&quot;1-数值的扩展&quot;&gt;&lt;a href=&quot;#1-数值的扩展&quot; class=&quot;headerlink&quot; title=&quot;1. 数值的扩展&quot;&gt;&lt;/a&gt;1. 数值的扩展&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Number.isFinite()  用来检查一个数值是否为有限的（finite);如果参数类型不是数值，Number.isFinite一律返回false。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;noise-code-block&quot; style=&quot;--code-block-max-height:inherit;&quot;&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Number.isFinite(15); // true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Number.isFinite(NaN); // false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Number.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，Number.isNaN一律返回false。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;noise-code-block&quot; style=&quot;--code-block-max-height:inherit;&quot;&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Number.isNaN(NaN) // true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Number.isNaN(&amp;quot;NaN&amp;quot;) // false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Number.parseInt()&lt;/li&gt;
&lt;li&gt;Number.parseFloat()&lt;/li&gt;
&lt;li&gt;Number.isInteger() 用来判断一个数值是否为整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;noise-code-block&quot; style=&quot;--code-block-max-height:inherit;&quot;&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Number.isInteger(25) // true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Number.isInteger(25.0) // true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Number.isInteger(25.1) // false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Math.trunc() 方法用于去除一个数的小数部分，返回整数部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;noise-code-block&quot; style=&quot;--code-block-max-height:inherit;&quot;&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Math.trunc(4.1) // 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.trunc(4.9) // 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.trunc(-4.1) // -4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.trunc(-4.9) // -4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.trunc(-0.1234) // -0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Math.sign() 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;参数为正数，返回+1；&lt;/li&gt;
&lt;li&gt;参数为负数，返回-1；&lt;/li&gt;
&lt;li&gt;参数为 0，返回0；&lt;/li&gt;
&lt;li&gt;参数为-0，返回-0;&lt;/li&gt;
&lt;li&gt;其他值，返回NaN。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;noise-code-block&quot; style=&quot;--code-block-max-height:inherit;&quot;&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Math.sign(-5) // -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.sign(5) // +1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.sign(0) // +0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.sign(-0) // -0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.sign(NaN) // NaN&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Math.cbrt() 方法用于计算一个数的立方根。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;noise-code-block&quot; style=&quot;--code-block-max-height:inherit;&quot;&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Math.cbrt(-1) // -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.cbrt(0)  // 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.cbrt(1)  // 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Math.cbrt(2)  // 1.2599210498948734&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;

&lt;br/&gt;


&lt;h4 id=&quot;2-Symbol&quot;&gt;&lt;a href=&quot;#2-Symbol&quot; class=&quot;headerlink&quot; title=&quot;2. Symbol&quot;&gt;&lt;/a&gt;2. Symbol&lt;/h4&gt;&lt;p&gt;原始数据类型Symbol,表示独一无二的值;它是 JavaScript 语言的第七种数据类型,"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>ES6,ES7,ES8小结(持续更新) | Mccc</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></div><div class="post-time">2018-11-02</div></div></div><div class="container post-header"><h1>ES6,ES7,ES8小结(持续更新)</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion"></summary><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7-2015"><span class="toc-number">1.</span> <span class="toc-text">ES6新特性(2015)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text">1. 数值的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Symbol"><span class="toc-number">1.2.</span> <span class="toc-text">2. Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Symbol%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%AF%B9-Symbol-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84-Symbol"><span class="toc-number">1.2.2.</span> <span class="toc-text">作为属性名的 Symbol</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Set"><span class="toc-number">1.3.</span> <span class="toc-text">3. Set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">set实例的属性和方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.</span> <span class="toc-text">遍历操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Map"><span class="toc-number">1.4.</span> <span class="toc-text">4. Map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">map实例的属性和方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">遍历操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">与其他数据结构的互相转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES7%E6%96%B0%E7%89%B9%E6%80%A7-2016"><span class="toc-number">2.</span> <span class="toc-text">ES7新特性(2016)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Array-prototype-includes"><span class="toc-number">2.1.</span> <span class="toc-text">1.Array.prototype.includes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2.指数操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES8%E6%96%B0%E7%89%B9%E6%80%A7-2017"><span class="toc-number">3.</span> <span class="toc-text">ES8新特性(2017)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-async-await"><span class="toc-number">3.1.</span> <span class="toc-text">1.async&#x2F;await</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-values"><span class="toc-number">3.2.</span> <span class="toc-text">2.Object.values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Object-entries"><span class="toc-number">3.3.</span> <span class="toc-text">3.Object.entries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-String-padding"><span class="toc-number">3.4.</span> <span class="toc-text">4.String padding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Object-getOwnPropertyDescriptors"><span class="toc-number">3.5.</span> <span class="toc-text">5.Object.getOwnPropertyDescriptors()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-SharedArrayBuffer%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.6.</span> <span class="toc-text">6.SharedArrayBuffer对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Atomics%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.7.</span> <span class="toc-text">7.Atomics对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES9%E6%96%B0%E7%89%B9%E6%80%A7-2018"><span class="toc-number">4.</span> <span class="toc-text">ES9新特性(2018)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Promise-finally"><span class="toc-number">4.1.</span> <span class="toc-text">1.Promise.finally()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Rest-Spread-%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">2.Rest&#x2F;Spread 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES10%E6%96%B0%E7%89%B9%E6%80%A7-2019"><span class="toc-number">5.</span> <span class="toc-text">ES10新特性(2019)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A1%8C%E5%88%86%E9%9A%94%E7%AC%A6%EF%BC%88U-2028%EF%BC%89%E5%92%8C%E6%AE%B5%E5%88%86%E9%9A%94%E7%AC%A6%EF%BC%88U-2029-%E7%AC%A6%E5%8F%B7%E7%8E%B0%E5%9C%A8%E5%85%81%E8%AE%B8%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97%E4%B8%AD%EF%BC%8C%E4%B8%8EJSON%E5%8C%B9%E9%85%8D"><span class="toc-number">5.1.</span> <span class="toc-text">1. 行分隔符（U + 2028）和段分隔符（U + 2029)符号现在允许在字符串文字中，与JSON匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9Eflat-%E5%92%8CflatMap-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2.数组新增flat()和flatMap()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Symbol-prototype-description"><span class="toc-number">5.3.</span> <span class="toc-text">3.Symbol.prototype.description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Object-fromEntries"><span class="toc-number">5.4.</span> <span class="toc-text">4. Object.fromEntries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Optional-chaining%EF%BC%88%E5%8F%AF%E9%80%89%E9%93%BE%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">2. Optional chaining（可选链）</span></a></li></ol></li></ol></details></div><div class="container post-content"><h3 id="ES6新特性-2015"><a href="#ES6新特性-2015" class="headerlink" title="ES6新特性(2015)"></a>ES6新特性(2015)</h3><h4 id="1-数值的扩展"><a href="#1-数值的扩展" class="headerlink" title="1. 数值的扩展"></a>1. 数值的扩展</h4><ul>
<li>Number.isFinite()  用来检查一个数值是否为有限的（finite);如果参数类型不是数值，Number.isFinite一律返回false。</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isFinite(15); // true</span><br><span class="line">Number.isFinite(NaN); // false</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Number.isNaN()用来检查一个值是否为NaN。如果参数类型不是NaN，Number.isNaN一律返回false。</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.isNaN(NaN) // true</span><br><span class="line">Number.isNaN(&quot;NaN&quot;) // false</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Number.parseInt()</li>
<li>Number.parseFloat()</li>
<li>Number.isInteger() 用来判断一个数值是否为整数。</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Number.isInteger(25) // true</span><br><span class="line">Number.isInteger(25.0) // true</span><br><span class="line">Number.isInteger(25.1) // false</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Math.trunc() 方法用于去除一个数的小数部分，返回整数部分。</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.trunc(4.1) // 4</span><br><span class="line">Math.trunc(4.9) // 4</span><br><span class="line">Math.trunc(-4.1) // -4</span><br><span class="line">Math.trunc(-4.9) // -4</span><br><span class="line">Math.trunc(-0.1234) // -0</span><br></pre></td></tr></table></figure></div>
<ul>
<li>Math.sign() 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值</li>
</ul>
<ol>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为 0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ol>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.sign(-5) // -1</span><br><span class="line">Math.sign(5) // +1</span><br><span class="line">Math.sign(0) // +0</span><br><span class="line">Math.sign(-0) // -0</span><br><span class="line">Math.sign(NaN) // NaN</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Math.cbrt() 方法用于计算一个数的立方根。</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt(-1) // -1</span><br><span class="line">Math.cbrt(0)  // 0</span><br><span class="line">Math.cbrt(1)  // 1</span><br><span class="line">Math.cbrt(2)  // 1.2599210498948734</span><br></pre></td></tr></table></figure></div>

<br/>


<h4 id="2-Symbol"><a href="#2-Symbol" class="headerlink" title="2. Symbol"></a>2. Symbol</h4><p>原始数据类型Symbol,表示独一无二的值;它是 JavaScript 语言的第七种数据类型,</p>
<p>七中数据类型:</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>布尔</li>
<li>字符串</li>
<li>对象</li>
<li>数值</li>
<li>Symbol</li>
</ul>
<h5 id="Symbol函数可以接受一个字符串作为参数，表示对-Symbol-实例的描述"><a href="#Symbol函数可以接受一个字符串作为参数，表示对-Symbol-实例的描述" class="headerlink" title="Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述"></a>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</h5><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol(&#x27;foo&#x27;);</span><br><span class="line">let s2 = Symbol(&#x27;bar&#x27;);</span><br><span class="line"></span><br><span class="line">s1 // Symbol(foo)</span><br><span class="line">s2 // Symbol(bar)</span><br><span class="line"></span><br><span class="line">s1.toString() // &quot;Symbol(foo)&quot;</span><br><span class="line">s2.toString() // &quot;Symbol(bar)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h5><p>对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line">// 第一种写法</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = &#x27;Hello!&#x27;;</span><br><span class="line"></span><br><span class="line">// 第二种写法</span><br><span class="line">let a = &#123;</span><br><span class="line">  [mySymbol]: &#x27;Hello!&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 第三种写法</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &#x27;Hello!&#x27; &#125;);</span><br><span class="line"></span><br><span class="line">// 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] // &quot;Hello!&quot;</span><br></pre></td></tr></table></figure></div>

<p>注意:Symbol 值作为对象属性名时，不能用点运算符。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const mySymbol = Symbol();</span><br><span class="line">const a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = &#x27;Hello!&#x27;;</span><br><span class="line">a[mySymbol] // undefined</span><br><span class="line">a[&#x27;mySymbol&#x27;] // &quot;Hello!&quot;</span><br></pre></td></tr></table></figure></div>


<p>Symbol用法,例:</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const shapeType = &#123;</span><br><span class="line">  triangle: Symbol()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getArea(shape, options) &#123;</span><br><span class="line">  let area = 0;</span><br><span class="line">  switch (shape) &#123;</span><br><span class="line">    case shapeType.triangle:</span><br><span class="line">      area = .5 * options.width * options.height;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<br/>

<h4 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h4><p>Set 本身是一个构造函数，用来生成 Set 数据结构;成员的值都是唯一的，没有重复的值;向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值;</p>
<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p>
<h5 id="set实例的属性和方法"><a href="#set实例的属性和方法" class="headerlink" title="set实例的属性和方法"></a>set实例的属性和方法</h5><ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
 <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set=new Set([1,2,1])</span><br><span class="line"></span><br><span class="line">set.size //2</span><br></pre></td></tr></table></figure></div>
<ul>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set();</span><br><span class="line"></span><br><span class="line">set.add(1).add(2);</span><br><span class="line"></span><br><span class="line">set.size //2</span><br><span class="line"></span><br><span class="line">set.has(1)  //true</span><br><span class="line"></span><br><span class="line">set.delete(1)  </span><br><span class="line"></span><br><span class="line">set.has(1)  //false</span><br><span class="line"></span><br><span class="line">set.clear()</span><br></pre></td></tr></table></figure></div>

<p>Array.from方法可以将 Set 结构转为数组,并且会去除重复的数据。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3]);</span><br><span class="line"></span><br><span class="line">const array = Array.from(set); //[1,2,3]</span><br></pre></td></tr></table></figure></div>

<p>这里还有一个简便的写法</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1,2,3]);</span><br><span class="line"></span><br><span class="line">const array = [...set]; //[1,2,3]</span><br></pre></td></tr></table></figure></div>

<h5 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h5><ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p>(1) keys方法、values方法、entries方法返回的都是遍历器对象</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">// [&quot;blue&quot;, &quot;blue&quot;]</span><br></pre></td></tr></table></figure></div>
<p>set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。可以省略values方法，直接用for…of循环遍历 Set。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]);</span><br><span class="line"></span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure></div>
<p>(2)forEach()<br>Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set = new Set([1, 4, 9]);</span><br><span class="line">set.forEach((value, key) =&gt; console.log(key + &#x27; : &#x27; + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure></div>
<p>数组的map和filter方法也可以间接用于 Set 了。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3]);</span><br><span class="line">set = new Set([...set].map(x =&gt; x * 2));</span><br><span class="line">// 返回Set结构：&#123;2, 4, 6&#125;</span><br><span class="line"></span><br><span class="line">let set = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">set = new Set([...set].filter(x =&gt; (x % 2) == 0));</span><br><span class="line">// 返回Set结构：&#123;2, 4&#125;</span><br></pre></td></tr></table></figure></div>

<br/>

<h4 id="4-Map"><a href="#4-Map" class="headerlink" title="4. Map"></a>4. Map</h4><p>JavaScript 的对象（Object）,但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">const o = &#123;p: &#x27;Hello World&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &#x27;content&#x27;)</span><br><span class="line">m.get(o) // &quot;content&quot;</span><br></pre></td></tr></table></figure></div>
<h5 id="map实例的属性和方法"><a href="#map实例的属性和方法" class="headerlink" title="map实例的属性和方法"></a>map实例的属性和方法</h5><ul>
<li><p>size 属性</p>
</li>
<li><p>set(key, value) 如果key已经有值，则键值会被更新，否则就新生成该键。</p>
</li>
<li><p>get(key) 如果找不到key，返回undefined。</p>
</li>
<li><p>has(key) </p>
</li>
<li><p>delete(key) 删除某个键，返回true。如果删除失败，返回false。</p>
</li>
<li><p>clear()</p>
</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(&#x27;edition&#x27;, 6).set(1, &#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">map.get(1) //&#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">map.has(1) //true</span><br><span class="line"></span><br><span class="line">map.delete(1) //true</span><br><span class="line"></span><br><span class="line">map.clear()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="遍历操作-1"><a href="#遍历操作-1" class="headerlink" title="遍历操作"></a>遍历操作</h5><ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ul>
<p>Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。</p>
<h5 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h5><p>（1）Map 转为数组<br>Map 转为数组最方便的方法，就是使用扩展运算符（…）。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const myMap = new Map()</span><br><span class="line">  .set(true, 7)</span><br><span class="line">  .set(&#123;foo: 3&#125;, [&#x27;abc&#x27;]);</span><br><span class="line">[...myMap]</span><br><span class="line">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span><br></pre></td></tr></table></figure></div>

<p>（2）数组 转为 Map<br>将数组传入 Map 构造函数，就可以转为 Map。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Map([</span><br><span class="line">  [true, 7],</span><br><span class="line">  [&#123;foo: 3&#125;, [&#x27;abc&#x27;]]</span><br><span class="line">])</span><br><span class="line">// Map &#123;</span><br><span class="line">//   true =&gt; 7,</span><br><span class="line">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></div>
<p>（3）Map 转为对象<br>如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function strMapToObj(strMap) &#123;</span><br><span class="line">  let obj = Object.create(null);</span><br><span class="line">  for (let [k,v] of strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myMap = new Map()</span><br><span class="line">  .set(&#x27;yes&#x27;, true)</span><br><span class="line">  .set(&#x27;no&#x27;, false);</span><br><span class="line">strMapToObj(myMap)</span><br><span class="line">// &#123; yes: true, no: false &#125;</span><br></pre></td></tr></table></figure></div>
<p>（4）对象转为 Map</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objToStrMap(obj) &#123;</span><br><span class="line">  let strMap = new Map();</span><br><span class="line">  for (let k of Object.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  return strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;yes: true, no: false&#125;)</span><br><span class="line">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span><br></pre></td></tr></table></figure></div>
<p>（5）Map 转为 JSON</p>
<p>（6）JSON 转为 Map</p>
<hr>
<h3 id="ES7新特性-2016"><a href="#ES7新特性-2016" class="headerlink" title="ES7新特性(2016)"></a>ES7新特性(2016)</h3><h4 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1.Array.prototype.includes()"></a>1.Array.prototype.includes()</h4><p>includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回 false</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#x27;react&#x27;, &#x27;angular&#x27;, &#x27;vue&#x27;];</span><br><span class="line"></span><br><span class="line">if (arr.includes(&#x27;react&#x27;)) &#123;</span><br><span class="line">	console.log(&#x27;react存在&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br/>


<h4 id="2-指数操作符"><a href="#2-指数操作符" class="headerlink" title="2.指数操作符"></a>2.指数操作符</h4><p>指数运算符 <code> ＊＊ </code> ,  <code>  ＊＊ </code>  具有与 <code> Math.pow(..) </code>  等效的计算结果。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2,10)   //1024</span><br><span class="line"></span><br><span class="line">2**10   //1024</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="ES8新特性-2017"><a href="#ES8新特性-2017" class="headerlink" title="ES8新特性(2017)"></a>ES8新特性(2017)</h3><h4 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1.async&#x2F;await"></a>1.async&#x2F;await</h4><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function process(array) &#123;</span><br><span class="line">	for await (let i of array) &#123;</span><br><span class="line">    	doSomething(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<br/>

<h4 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2.Object.values()"></a>2.Object.values()</h4><p><code> Object.values() </code> 是一个与 <code> Object.keys() </code> 类似的新函数，但返回的是Object自身属性的所有值，<strong><u>不包括继承的值</u></strong></p>
<p>假设我们要遍历如下对象 obj的所有值：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj=&#123;a:1,b:2,c:3&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const keys=Object.keys(obj)    //[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line">const values=Object.values(obj)   // [1,2,3]</span><br></pre></td></tr></table></figure></div>

<br/>


<h4 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3.Object.entries()"></a>3.Object.entries()</h4><p><code>Object.entries()</code> 函数返回一个给定对象自身可枚举属性的键值对的数组。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj=&#123;a:1,b:2,c:3&#125;;</span><br><span class="line"></span><br><span class="line">for (const [key, value] of Object.entries(obj)) &#123;</span><br><span class="line">	console.log(`key:$&#123;key&#125;  value $&#123;value&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// key:a  value 1</span><br><span class="line">// key:b  value 2</span><br><span class="line">// key:c  value 3</span><br></pre></td></tr></table></figure></div>

<br/>


<h4 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4.String padding"></a>4.String padding</h4><p>String新增了两个实例函数<code> String.prototype.padStart</code>和 <code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.padStart(targetLength,[padString])</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>targetLength:当前字符串需要填充到的目标长度。<strong><u>如果这个数值小于当前字符串的长度，则返回当前字符串本身</u></strong>。</p>
</li>
<li><p>padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，如果字符串太短,不足与填充,则会循环字符串以填充,此参数的缺省值为 “ “。</p>
</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a=&#x27;0.0&#x27;;</span><br><span class="line">a.padStart(2,&#x27;10&#x27;);  //&#x27;0.0&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.padStart(10);    //&#x27;          0.0&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.padStart(5,&#x27;10&#x27;)   //&#x27;100.0&#x27;</span><br><span class="line">a.padStart(5,&#x27;123&#x27;)  //&#x27;120.0&#x27;</span><br><span class="line">a.padStart(6,&#x27;10&#x27;)   //&#x27;1010.0&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.padEnd(targetLength,padString])</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>targetLength:当前字符串需要填充到的目标长度。<strong><u>如果这个数值小于当前字符串的长度，则返回当前字符串本身</u></strong>。</p>
</li>
<li><p>padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，如果字符串太短,不足与填充,则会循环字符串以填充,此参数的缺省值为 “ “；</p>
</li>
</ul>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a=&#x27;0.0&#x27;;</span><br><span class="line">a.padEnd(2,&#x27;10&#x27;);  //&#x27;0.0&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.padEnd(10);    //&#x27;0.0          &#x27;</span><br></pre></td></tr></table></figure></div>

<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.padEnd(5,&#x27;10&#x27;)   //&#x27;0.010&#x27;</span><br><span class="line">a.padEnd(5,&#x27;123&#x27;)  //&#x27;0.012&#x27;</span><br><span class="line">a.padEnd(6,&#x27;10&#x27;)   //&#x27;0.0101&#x27;</span><br></pre></td></tr></table></figure></div>

<br/>

<h4 id="5-Object-getOwnPropertyDescriptors"><a href="#5-Object-getOwnPropertyDescriptors" class="headerlink" title="5.Object.getOwnPropertyDescriptors()"></a>5.Object.getOwnPropertyDescriptors()</h4><p><code>Object.getOwnPropertyDescriptors()</code> 函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const obj2 = &#123;</span><br><span class="line">	name: &#x27;Jack&#x27;,</span><br><span class="line">    get age() &#123; return &#x27;20&#x27;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptors(obj2)</span><br><span class="line"></span><br><span class="line">// age: &#123;</span><br><span class="line">//    configurable:true,</span><br><span class="line">//    enumerable:true,</span><br><span class="line">//    get:f age()..</span><br><span class="line">//    set:undefined,</span><br><span class="line">// &#125;</span><br><span class="line">// name:&#123;</span><br><span class="line">//    configurable:true,</span><br><span class="line">//    enumerable:true,</span><br><span class="line">//    value:&#x27;Jack&#x27;,</span><br><span class="line">//    writable:true,</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>value</strong>:与属性关联的值（仅限数据描述符)</li>
<li><strong>writable</strong>:<code>true</code> 当且仅当与属性关联的值可能被更改时（仅限数据描述符）。</li>
<li><strong>get</strong>:一个函数，用作属性的getter，或者undefined如果没有getter（仅限访问者描述符）。</li>
<li><strong>set</strong>:一个函数，用作属性的setter，或者undefined如果没有setter（仅限访问者描述符）。</li>
<li><strong>configurable</strong>:true 当且仅当可以更改此属性描述符的类型并且可以从相应对象中删除该属性时。</li>
<li><strong>enumerable</strong>:true 当且仅当在枚举相应对象的属性期间显示此属性时。</li>
</ul>
<br/>

<h4 id="6-SharedArrayBuffer对象"><a href="#6-SharedArrayBuffer对象" class="headerlink" title="6.SharedArrayBuffer对象"></a>6.SharedArrayBuffer对象</h4><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ShareArrayBuffer(length)</span><br></pre></td></tr></table></figure></div>

<br/>


<h4 id="7-Atomics对象"><a href="#7-Atomics对象" class="headerlink" title="7.Atomics对象"></a>7.Atomics对象</h4><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p>
<hr>
<h3 id="ES9新特性-2018"><a href="#ES9新特性-2018" class="headerlink" title="ES9新特性(2018)"></a>ES9新特性(2018)</h3><h4 id="1-Promise-finally"><a href="#1-Promise-finally" class="headerlink" title="1.Promise.finally()"></a>1.Promise.finally()</h4><p><code>.finally()</code> 允许你指定最终的逻辑：</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">	doSomething1(4)</span><br><span class="line">    	.then(() =&gt; &#123;</span><br><span class="line">          return doSomething2(2);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err =&gt; &#123;</span><br><span class="line">          console.log(err);</span><br><span class="line">        &#125;)</span><br><span class="line">        .finally(() =&gt; &#123;</span><br><span class="line">          console.log(&#x27;finally&#x27;)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<br/>


<h4 id="2-Rest-Spread-属性"><a href="#2-Rest-Spread-属性" class="headerlink" title="2.Rest&#x2F;Spread 属性"></a>2.Rest&#x2F;Spread 属性</h4><p>提供了和Rest一样的参数</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Obj=&#123;</span><br><span class="line">	a:1,</span><br><span class="line">    b:2,</span><br><span class="line">    c:3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;a,...x&#125; = Obj;</span><br></pre></td></tr></table></figure></div>
<hr>
<h3 id="ES10新特性-2019"><a href="#ES10新特性-2019" class="headerlink" title="ES10新特性(2019)"></a>ES10新特性(2019)</h3><h4 id="1-行分隔符（U-2028）和段分隔符（U-2029-符号现在允许在字符串文字中，与JSON匹配"><a href="#1-行分隔符（U-2028）和段分隔符（U-2029-符号现在允许在字符串文字中，与JSON匹配" class="headerlink" title="1. 行分隔符（U + 2028）和段分隔符（U + 2029)符号现在允许在字符串文字中，与JSON匹配"></a>1. 行分隔符（U + 2028）和段分隔符（U + 2029)符号现在允许在字符串文字中，与JSON匹配</h4><br/>

<h4 id="2-数组新增flat-和flatMap-方法"><a href="#2-数组新增flat-和flatMap-方法" class="headerlink" title="2.数组新增flat()和flatMap()方法"></a>2.数组新增<code>flat()</code>和<code>flatMap()</code>方法</h4><p> flat()<br> <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></div></p>
<p> flatMap()<br> <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4].flatMap(a =&gt; [a**2]); // [1, 4, 9, 16]</span><br></pre></td></tr></table></figure></div></p>
 <br>
 
<h4 id="3-Symbol-prototype-description"><a href="#3-Symbol-prototype-description" class="headerlink" title="3.Symbol.prototype.description"></a>3.Symbol.prototype.description</h4><p> 只读属性，回 Symbol 对象的可选描述的字符串。</p>
 <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Symbol(&#x27;description&#x27;).description; // &#x27;description&#x27;</span><br></pre></td></tr></table></figure></div>
 <br>
 
<h4 id="4-Object-fromEntries"><a href="#4-Object-fromEntries" class="headerlink" title="4. Object.fromEntries()"></a>4. Object.fromEntries()</h4><p>  返回一个给定对象自身可枚举属性的键值对数组<br>  <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Object.fromEntries， 可以将 Map 转化为 Object:</span><br><span class="line">const map = new Map([ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]);</span><br><span class="line">console.log(Object.fromEntries(map)); // &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span><br></pre></td></tr></table></figure></div></p>
  <br>
 ___
 ### ES11新特性(2020)
 #### 1. Nullish coalescing Operator(空值处理)
   表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。

   <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line"> u1: 0,</span><br><span class="line"> u2: false,</span><br><span class="line"> u3: null,</span><br><span class="line"> u4: undefined</span><br><span class="line"> u5: &#x27;&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">let u2 = user.u2 ?? &#x27;用户2&#x27;  // false</span><br><span class="line">let u3 = user.u3 ?? &#x27;用户3&#x27;  // 用户3</span><br><span class="line">let u4 = user.u4 ?? &#x27;用户4&#x27;  // 用户4</span><br><span class="line">let u5 = user.u5 ?? &#x27;用户5&#x27;  // &#x27;&#x27;</span><br></pre></td></tr></table></figure></div>
  <br>
  
<h4 id="2-Optional-chaining（可选链）"><a href="#2-Optional-chaining（可选链）" class="headerlink" title="2. Optional chaining（可选链）"></a>2. Optional chaining（可选链）</h4><p>   ?.用户检测不确定的中间节点</p>
   <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;</span><br><span class="line">let u1 = user.childer.name // TypeError: Cannot read property &#x27;name&#x27; of undefined</span><br><span class="line">let u1 = user.childer?.name // undefined</span><br></pre></td></tr></table></figure></div>
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"Ov23li8ntBo0XKvstJme","clientSecret":"b0fc92ee81f6ee3e9e1e447c6c1f0715d3732681","repo":"hexo-plugin-gitalk","owner":"angelise7","admin":["angelise7"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script></div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>