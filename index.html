<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Mccc | </title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><header class="wrapper header"><div class="container blog-title"><a class="title" id="logo" href="/.">Mccc</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div><input id="menu" type="checkbox"><div class="container nav-items"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></div></header><article class="wrapper"><div class="container entries" id="index-main"><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2025/07/15/Rxjs-Challenges/">Rxjs中concatMap、switchMap、exhaustMap、mergeMap详解</a></div><div class="post-content"><p>之前对Rxjs的concatMap、switchMap、exhaustMap、mergeMap这四个映射操作符的理解有欠缺，以下是对这四个操作符的深入理解。首先在理解这四个操作符之前一定要理解的概念就是<code>源数据</code>和<code>映射Observable</code>,我们可以把这两部分想象成流水线工厂的<code>原材料</code>和<code>加工机器</code>,一定要独立的理解这两部分，这四个操作符不同的地方就是在<code>加工机器</code>这一部分使用了不同的逻辑,以此来产出不同的结果</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Rxjs/" rel="tag">Rxjs</a></div><div class="post-time">2025-07-15</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2024/04/22/JSON-Schema%E5%88%9D%E6%8E%A2/">JSON Schema初探</a></div><div class="post-content"><p>最近由于项目需要,需要非开发人员根据业务数据的手动录入表单并且可以同步输出对应的JSON数据.记录下整个业务分析和最终实现的过程.</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/JSON-Schema/" rel="tag">JSON Schema</a></div><div class="post-time">2024-04-22</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2023/09/21/ChatGPT%E4%B8%8E%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E5%92%8C%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E7%BB%93%E5%90%88%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E8%A7%89/">ChatGPT与讯飞语音识别和语音合成结合中的问题总结</a></div><div class="post-content"><p>首先是下面的流程图,最终呈现的效果为,用户开启语音输入,识别问题后调用GPT获得结果的同时向讯飞发起语音合成.</p></div><div class="post-meta"><div class="post-time">2023-09-21</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2023/09/21/%E4%BB%A5ChatGPT%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%BB%93%E5%90%88ChatVRM-%E8%AE%AF%E9%A3%9E%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E5%92%8C%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E6%96%B9%E6%A1%88%E4%BB%8B%E7%BB%8D/">以ChatGPT为基础结合ChatVRM,讯飞语音合成和语音识别前端方案介绍</a></div><div class="post-content"><p>以ChatGPT为基础结合ChatVRM,讯飞语音合成和语音识别实现的前端方案中,单纯的从前端角度出发简要描述各个技术的结合.</p></div><div class="post-meta"><div class="post-time">2023-09-21</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2023/01/16/Promsie%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">Promise深度解析</a></div><div class="post-content"><p>之前对于Promise并没有深度的了解过,闲来无事手写了Promise,过程中对Promise有了更进一步的了解,其中比较难的就在于<code>then()</code>的内部处理,之所以能实现链式调用和异步处理,最重要的核心就是一旦调用了<code>then()</code>方法,内部就会重启一个新的Promise并将其返回,并根据Promise的状态来做不一样的处理</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/JS/" rel="tag">JS</a></div><div class="post-time">2023-01-16</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2022/11/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Typescript/">深入理解Typescript</a></div><div class="post-content"><p>针对基础的Ts知识不做过多解释,相关文档查阅即可.本文注重对于类型操作中的难点和日常项目中的高频类型等做整理.本文会在内置的高级类型基础上延展.<br>针对内置的高级类型,这里按照操作类型做了简单的分类.</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Typescript/" rel="tag">Typescript</a></div><div class="post-time">2022-11-25</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2022/07/28/Angular%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-Eslint%E5%8F%8ACz%E5%B7%A5%E5%85%B7%E9%9B%86/">Angular代码规范:Eslint及Cz工具集</a></div><div class="post-content"><p>本文主要记录Eslint和Cz工具集配置过程:</p></div><div class="post-meta"><div class="post-time">2022-07-28</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2022/07/27/Angular-viewport-%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/">Angular-Viewport适配方案</a></div><div class="post-content"><p>本文你主要用于记录viewport适配方案在Ng中的应用.具体viewport方案的优劣和介绍不做过多介绍.</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Angualr/" rel="tag">Angualr</a></div><div class="post-time">2022-07-27</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2022/02/15/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%9C%A8Angular%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%90%E7%94%A8/">装饰器与Angular</a></div><div class="post-content"><p>装饰器在Angular中是个很常见的概念,<code>@Component</code>、<code>@Directive</code>、<code>@Pipe</code>、<code>@NgModule</code>、<code>@Injectable</code>、<code>@Input</code>、<code>@Inject</code>等等.本文着重讲解各种装饰器的作用以及在Angular中的实际使用</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Angular/" rel="tag">Angular</a></div><div class="post-time">2022-02-15</div></div></div></div><div class="post-entry"><div class="post-desc"><div class="post-title"><a href="/2021/12/08/V8/">浅谈V8</a></div><div class="post-content"><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul>
<li>解析器(parser):将JS代码解析成抽象语法树AST</li>
<li>解释器(Ignition):将抽象语法树(AST)解释成字节码(bytecode),同时可以解释执行字节码的能力</li>
<li>编译器(TurboFan):编译出高效的机器代码</li>
</ul>
<br>

<h3 id="V8的惰性解析和预解析"><a href="#V8的惰性解析和预解析" class="headerlink" title="V8的惰性解析和预解析"></a>V8的惰性解析和预解析</h3><p>V8的解析阶段会将源文本解析为抽象语法树,再交由解释器解释成字节码,事实上,解析前会经历一系列的操作;这个过程大根是先将<b><font color="red">源文本(UTF-8、Latin1、ASCII)</font></b>转为<b><font color="red">UTF-16的字符流</font></b>,<b><font color="red">扫描器(Scanner)</font></b>通过组合底层字符流中的连续字符来构<b><font color="red">造这些标记</font></b>。然后提供给解析器;</p></div><div class="post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/V8/" rel="tag">V8</a></div><div class="post-time">2021-12-08</div></div></div></div></div></article><div class="wrapper page-navigator-wrapper"><div class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next »</a></div></div><footer class="footer wrapper"><div class="social"><a href="mailto:249749871@qq.com" target="_blank"><i class="fa fa-envelope-o"></i></a><a href="https://github.com/angelise7" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer-content">© 2025 <a href="/" rel="nofollow">Mccc</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/hexo-theme-noise">noise</a>.</div></footer><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>