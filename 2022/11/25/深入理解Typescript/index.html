<!DOCTYPE html><html lang="zh-cn"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="针对基础的Ts知识不做过多解释,相关文档查阅即可.本文注重对于类型操作中的难点和日常项目中的高频类型等做整理.本文会在内置的高级类型基础上延展.&lt;br&gt;针对内置的高级类型,这里按照操作类型做了简单的分类."><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>深入理解Typescript | Mccc</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-noise-link" href="/tags/Typescript/" rel="tag">Typescript</a></div><div class="post-time">2022-11-25</div></div></div><div class="container post-header"><h1>深入理解Typescript</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion"></summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">1.函数类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Parmeters"><span class="toc-number">1.1.</span> <span class="toc-text">1.Parmeters&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ReturnType"><span class="toc-number">1.2.</span> <span class="toc-text">2.ReturnType&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%83%E7%BB%84%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2.元组类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Exclude"><span class="toc-number">2.1.</span> <span class="toc-text">1.Exclude&lt;T,U&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Extract"><span class="toc-number">2.2.</span> <span class="toc-text">2.Extract&lt;T,U&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">3.索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Partial"><span class="toc-number">3.1.</span> <span class="toc-text">1.Partial&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Required"><span class="toc-number">3.2.</span> <span class="toc-text">2.Required&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Readonly"><span class="toc-number">3.3.</span> <span class="toc-text">3.Readonly&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E9%9D%A2%E4%B8%89%E7%A7%8D%E5%86%85%E7%BD%AE%E7%9A%84%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%85%B7%E6%9C%89%E4%BB%A3%E8%A1%A8%E6%80%A7-%E5%85%B6%E4%BD%99%E7%9A%84%E6%AF%94%E5%A6%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8CPromise%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3-%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%85%B7%E6%9C%89%E4%BB%A3%E8%A1%A8%E6%80%A7-%E4%B8%8D%E5%81%9A%E8%BF%87%E5%BE%97%E8%A7%A3%E9%87%8A-%E9%A2%9D%E5%A4%96%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%87%A0%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B-%E6%9D%A5%E6%80%BB%E7%BB%93%E5%85%B6%E4%BD%99%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">上面三种内置的高级类型具有代表性,其余的比如构造函数和Promise相关的类型可以参考官网文档,因为不具有代表性,不做过得解释.额外添加了几个自定义高级类型,来总结其余的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%92%E5%BD%92%E5%BE%AA%E7%8E%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">1.递归循环与模板字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8E%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2.模板字面量与联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-any%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3.any类型的交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-any%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">4.any类型作为参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%83%E7%A5%96%E7%B1%BB%E5%9E%8B%E7%9A%84length%E4%B8%8E%E6%95%B0%E7%BB%84length"><span class="toc-number">4.5.</span> <span class="toc-text">5.元祖类型的length与数组length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%AF%E9%80%89%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%AF%E8%83%BD%E6%B2%A1%E6%9C%89%EF%BC%8CPick-%E5%87%BA%E6%9D%A5%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E6%98%AF"><span class="toc-number">4.6.</span> <span class="toc-text">6.可选索引的索引可能没有，Pick 出来的就可能是 {}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="toc-number">4.7.</span> <span class="toc-text">7.数值计算</span></a></li></ol></li></ol></details></div><div class="container post-content"><p>针对基础的Ts知识不做过多解释,相关文档查阅即可.本文注重对于类型操作中的难点和日常项目中的高频类型等做整理.本文会在内置的高级类型基础上延展.<br>针对内置的高级类型,这里按照操作类型做了简单的分类.</p>
<h2 id="1-函数类"><a href="#1-函数类" class="headerlink" title="1.函数类"></a>1.函数类</h2><h3 id="1-Parmeters"><a href="#1-Parmeters" class="headerlink" title="1.Parmeters&lt;T&gt;"></a>1.<code>Parmeters&lt;T&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回函数的参数类型</span><br><span class="line"> */</span><br><span class="line">type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (</span><br><span class="line">  ...args: infer P</span><br><span class="line">) =&gt; any</span><br><span class="line">  ? P</span><br><span class="line">  : never;</span><br><span class="line">  </span><br><span class="line"> //e.g. </span><br><span class="line"> type FunctionParamsType = Parameters&lt;(arg1: string, arg2: number) =&gt; &#123;&#125;&gt;; </span><br><span class="line"> //expected to be [arg1: string, arg2: number]  </span><br></pre></td></tr></table></figure></div>
<h3 id="2-ReturnType"><a href="#2-ReturnType" class="headerlink" title="2.ReturnType&lt;T&gt;"></a>2.<code>ReturnType&lt;T&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * 返回函数的返回类型</span><br><span class="line">  */</span><br><span class="line"> type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (</span><br><span class="line">   ...args: any</span><br><span class="line"> ) =&gt; infer R</span><br><span class="line">   ? R</span><br><span class="line">   : never;</span><br><span class="line"></span><br><span class="line"> //e.g.</span><br><span class="line"> type FunctionReturnType = ReturnType&lt;() =&gt; &#x27;string&#x27;&gt;;  </span><br><span class="line">// expected to be string</span><br></pre></td></tr></table></figure></div>

<p>以上两个高级类型中有三个知识点</p>
<p><b>1. 类型约束 <code>extends</code></b> <br><br>   入参部分的<code>T extends  (...args: any) =&gt; any</code>用来约束入参的类型为函数类型</p>
<p><b>2. 条件：<code>extends ? :</code></b> <br><br>   类似JS中的三元运算,比如<code>T extends number?true:false</code>经过计算返回布尔类型,如果T的类型是number则返回true,否则false</p>
<p><b>3.infer 推导</b> <br><br>   当在类型计算过程中需要提取其中的类型时,我们可以再适当的位置加 <code>infer </code>来声明部分类型</p>
<h2 id="2-元组类"><a href="#2-元组类" class="headerlink" title="2.元组类"></a>2.元组类</h2><h3 id="1-Exclude"><a href="#1-Exclude" class="headerlink" title="1.Exclude&lt;T,U&gt;"></a>1.<code>Exclude&lt;T,U&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从联合类型中排除一部分类型,构造类型</span><br><span class="line"> */</span><br><span class="line">type Exclude&lt;T, U&gt; = T extends U ? never : T;</span><br><span class="line">//e.g.</span><br><span class="line">type UnionExclude = Exclude&lt;&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;, &#x27;a&#x27; | &#x27;b&#x27;&gt;;</span><br><span class="line">//expected to be  &#x27;c&#x27;|&#x27;d&#x27;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-Extract"><a href="#2-Extract" class="headerlink" title="2.Extract&lt;T,U&gt;"></a>2.<code>Extract&lt;T,U&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从两个联合类型中取交集,构造类型</span><br><span class="line"> */</span><br><span class="line">type Extract&lt;T, U&gt; = T extends U ? T : never;</span><br><span class="line">//e.g.</span><br><span class="line">type UnionExtract = Extract&lt;&#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;, &#x27;a&#x27; | &#x27;b&#x27;&gt;;</span><br><span class="line">// expected to be &#x27;a&#x27;|&#x27;b&#x27;</span><br></pre></td></tr></table></figure></div>
<p>这其中有个重要的知识点就是分布式条件类型,<b><u>即类型参数为联合类型</u></b>时,<b><u>并且在条件类型左边直接引用该类型参数的时候</u></b>，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型.</p>
<p>分布式条件类型条件: <br><br><b>1. 入参为联合类型</b> <br><br><b>2. <code>extends</code>左边直接对联合类型进行引用</b> A extends A 是分布式条件类型 ;[A] extends [A] 不是是分布式条件类型<br></p>
<p>所以再回头分析<code>Exclude&lt;&#39;a&#39; | &#39;b&#39; | &#39;c&#39; | &#39;d&#39;, &#39;a&#39; | &#39;b&#39;&gt;</code>,<code>T extends U</code>右边类型保持不变,将<code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39; | &#39;d&#39;</code>拆开依次传入,第一次结果<code>&#39;a&#39; extends &#39;a&#39;|&#39;b&#39;</code>,结果为never;第二次<code>&#39;b&#39; extends &#39;a&#39;|&#39;b&#39;</code>,结果为never;第三次<code>&#39;c&#39; extends &#39;a&#39;|&#39;b&#39;</code>,结果为<code>&#39;c&#39;</code>;第四次<code>&#39;d&#39; extends &#39;a&#39;|&#39;b&#39;</code>,结果为<code>&#39;d&#39;</code>,最后将结果在重新组合成联合类型即<code>&#39;c&#39;|&#39;d&#39;</code>;</p>
<h2 id="3-索引类型"><a href="#3-索引类型" class="headerlink" title="3.索引类型"></a>3.索引类型</h2><h3 id="1-Partial"><a href="#1-Partial" class="headerlink" title="1.Partial&lt;T&gt;"></a>1.<code>Partial&lt;T&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构造一个所有属性都可选的类型</span><br><span class="line"> */</span><br><span class="line">type Partial&lt;T&gt; = &#123;</span><br><span class="line">  [key in keyof T]?: T[key];</span><br><span class="line">&#125;;</span><br><span class="line">//e.g.</span><br><span class="line">type IndexTypePartial = Partial&lt;&#123; a: number; b: string &#125;&gt;;</span><br><span class="line">//expected to be  &#123;a?: number | undefined;b?: string | undefined;&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-Required"><a href="#2-Required" class="headerlink" title="2.Required&lt;T&gt;"></a>2.<code>Required&lt;T&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构造一个所有属性都必须得类型</span><br><span class="line"> */</span><br><span class="line">type Required&lt;T&gt; = &#123;</span><br><span class="line">  [key in keyof T]-?: T[key];</span><br><span class="line">&#125;;</span><br><span class="line">//e.g.</span><br><span class="line">type IndexTypeRequired = Required&lt;&#123; a?: number; b: string &#125;&gt;;</span><br><span class="line">//expected to be  &#123;a: number;b: string &#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-Readonly"><a href="#3-Readonly" class="headerlink" title="3.Readonly&lt;T&gt;"></a>3.<code>Readonly&lt;T&gt;</code></h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构造一个所有属性都是只读的类型</span><br><span class="line"> */</span><br><span class="line">type Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [key in keyof T]: T[key];</span><br><span class="line">&#125;;</span><br><span class="line">//e.g.</span><br><span class="line">type IndexTypeReadonly = Readonly&lt;&#123; a: number; b: string &#125;&gt;;</span><br><span class="line">//expected to be &#123; readonly a: number;readonly  b: string &#125;</span><br></pre></td></tr></table></figure></div>

<p>以上三个类型都用到一个知识点是索引类型的重新构造,索引类型有readonly(只读),?(可选)两种修饰符,这个过程中可以对<code>Value值</code>和<code>Key值</code>进行修改,Value值修改直接写入新的类型即可,Key值的修改要用的as,即<font color="red"><b><code>重映射</code></b> </font></p>
<p>下面的例子将Value值类型全部改写为boolean</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Mapping&lt;Obj extends object&gt; = &#123; </span><br><span class="line">   [Key in keyof Obj]: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Res=Mapping&lt;&#123;a:number,b:string&#125;&gt;</span><br><span class="line">//expected to be &#123; a: boolean; b: boolean &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>下面的例子是将索引类型的Key大写<br><br>因为索引可能是string、number、symbol,而Uppercase只能接受string所以通过交叉类型来限制入参</p>
 <div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type UppercaseKey&lt;Obj extends object&gt; = &#123; </span><br><span class="line">  [Key in keyof Obj as Uppercase&lt;Key &amp; string&gt;]: Obj[Key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<h2 id="上面三种内置的高级类型具有代表性-其余的比如构造函数和Promise相关的类型可以参考官网文档-因为不具有代表性-不做过得解释-额外添加了几个自定义高级类型-来总结其余的知识点"><a href="#上面三种内置的高级类型具有代表性-其余的比如构造函数和Promise相关的类型可以参考官网文档-因为不具有代表性-不做过得解释-额外添加了几个自定义高级类型-来总结其余的知识点" class="headerlink" title="上面三种内置的高级类型具有代表性,其余的比如构造函数和Promise相关的类型可以参考官网文档,因为不具有代表性,不做过得解释.额外添加了几个自定义高级类型,来总结其余的知识点"></a>上面三种内置的高级类型具有代表性,其余的比如构造函数和Promise相关的类型可以参考官网文档,因为不具有代表性,不做过得解释.额外添加了几个自定义高级类型,来总结其余的知识点</h2><h3 id="1-递归循环与模板字面量"><a href="#1-递归循环与模板字面量" class="headerlink" title="1.递归循环与模板字面量"></a>1.递归循环与模板字面量</h3><p><code>CamelCaes&lt;T&gt;</code>,将连字符字符串转驼峰,比如start_time&#x3D;&gt;startTime,</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type CamelCaes&lt;S extends string&gt; = S extends `$&#123;infer First&#125;_$&#123;infer Rest&#125;`</span><br><span class="line">   ? `$&#123;First&#125;$&#123;CamelCaes&lt;Capitalize&lt;Rest&gt;&gt;&#125;`</span><br><span class="line">   : S;</span><br></pre></td></tr></table></figure></div>
<p>上面的自定义类型用到了两个知识点:<font color="red"><code>模板字面量</code></font>和<font color="red"><code>递归循环</code></font></p>
<p>模板字面量,类似JS中的语法一样,在合适的位置通过infer声明变量,再通过条件类型提取出来.</p>
<p>下面的例子,我们通过_下划线来构建,左边部分和右边部分,下划线左边部分保持不变,下划线右边部分调用内置类型<code>Capitalize</code>将首字母大写;但是仅仅这样,如果超过三个以上的单词则无法满足;</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> type CamelCaes&lt;S extends string&gt; = S extends `$&#123;infer First&#125;_$&#123;infer Rest&#125;`</span><br><span class="line">   ? `$&#123;First&#125;$&#123;Capitalize&lt;Rest&gt;&#125;`</span><br><span class="line">   : S;</span><br><span class="line"> type Res = CamelCaes&lt;&#x27;activity_product_detail&#x27;&gt;;</span><br><span class="line">//expected to be &#x27;activityProduct_detail&#x27;   </span><br></pre></td></tr></table></figure></div>

<p>所以对于右边的剩余部分,我们就要采用递归的方法,继续调用;<code>$&#123;First&#125;$&#123;CamelCaes&lt;Capitalize&lt;Rest&gt;&gt;&#125;</code></p>
<h3 id="2-模板字面量与联合类型"><a href="#2-模板字面量与联合类型" class="headerlink" title="2.模板字面量与联合类型"></a>2.模板字面量与联合类型</h3><p>字符串类型中遇到联合类型的时候，会每个元素单独传入计算,无需再进行递归循环,最典型的例子就是BEM规范</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type BEM&lt;</span><br><span class="line">  B extends string,</span><br><span class="line">  E extends string[],</span><br><span class="line">  M extends string[]</span><br><span class="line">&gt; = `$&#123;B&#125;__$&#123;E[number]&#125;--$&#123;M[number]&#125;`;</span><br><span class="line"></span><br><span class="line">type res = BEM&lt;&#x27;btn&#x27;, [&#x27;price&#x27;], [&#x27;success&#x27;, &#x27;error&#x27;]&gt;;</span><br><span class="line">//expected to be &quot;btn__price--success&quot; | &quot;btn__price--error&quot;</span><br></pre></td></tr></table></figure></div>


<h3 id="3-any类型的交叉类型"><a href="#3-any类型的交叉类型" class="headerlink" title="3.any类型的交叉类型"></a>3.any类型的交叉类型</h3><p>any 类型与任何类型的交叉都是 any,所以可以用这个特性来判断一个类型是否是any</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type IsAny&lt;T&gt; = number extends (number &amp; T) ? true : false</span><br></pre></td></tr></table></figure></div>

<h3 id="4-any类型作为参数"><a href="#4-any类型作为参数" class="headerlink" title="4.any类型作为参数"></a>4.any类型作为参数</h3><p>any 在条件类型中也比较特殊，如果类型参数为 any，会直接返回 trueType 和 falseType 的合并</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type TestAny&lt;T&gt; = T extends number ? 1 : 2;</span><br><span class="line"></span><br><span class="line">type Res=TestAny&lt;any&gt;</span><br><span class="line">//expected to be 1|2</span><br></pre></td></tr></table></figure></div>

<h3 id="5-元祖类型的length与数组length"><a href="#5-元祖类型的length与数组length" class="headerlink" title="5.元祖类型的length与数组length"></a>5.元祖类型的length与数组length</h3><p>元组类型的 length 是数字字面量，而数组的 length 是 number。</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type len=[1,2,3][&#x27;length]</span><br><span class="line">//expected to be 3</span><br><span class="line"></span><br><span class="line">type len2=number[][&#x27;length]</span><br><span class="line">//expected to number</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="6-可选索引的索引可能没有，Pick-出来的就可能是"><a href="#6-可选索引的索引可能没有，Pick-出来的就可能是" class="headerlink" title="6.可选索引的索引可能没有，Pick 出来的就可能是 {}"></a>6.可选索引的索引可能没有，Pick 出来的就可能是 {}</h3><div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type res = &#123;&#125; extends Pick&lt;&#123; a?: 1 &#125;, &#x27;a&#x27;&gt; ? true : false;</span><br><span class="line">//expected to be  true</span><br></pre></td></tr></table></figure></div>
<p>通过这个特点可以自定义一个类型用来过滤可选索引</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type GetOptional&lt;Obj extends  Record&lt;string, any&gt;&gt; = &#123;</span><br><span class="line">    [</span><br><span class="line">        Key in keyof Obj </span><br><span class="line">            as &#123;&#125; extends Pick&lt;Obj, Key&gt; ? Key : never</span><br><span class="line">    ] : Obj[Key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>反过来也过滤非可选索引</p>
<h3 id="7-数值计算"><a href="#7-数值计算" class="headerlink" title="7.数值计算"></a>7.数值计算</h3><p>这一部分在TS中算是比较难得知识点,核心用法就是利用数组的长度属性来出来.</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type res=[1,2,3][&#x27;length&#x27;]  //expected to 3</span><br><span class="line">type res=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;][&#x27;length&#x27;]  //expected to 3</span><br></pre></td></tr></table></figure></div>
<p>举例求两个数的和</p>
<div class="noise-code-block" style="--code-block-max-height:inherit;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type BuildArray&lt;</span><br><span class="line">  Length extends number,</span><br><span class="line">  Ele = unknown,</span><br><span class="line">  Arr extends unknown[] = []</span><br><span class="line">&gt; = Arr[&#x27;length&#x27;] extends Length</span><br><span class="line">  ? Arr</span><br><span class="line">  : BuildArray&lt;Length, Ele, [...Arr, Ele]&gt;;</span><br><span class="line"></span><br><span class="line">type Add&lt;Num1 extends number, Num2 extends number&gt; = [</span><br><span class="line">  ...BuildArray&lt;Num1&gt;,</span><br><span class="line">  ...BuildArray&lt;Num2&gt;</span><br><span class="line">][&#x27;length&#x27;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//e.g.</span><br><span class="line">type res = Add&lt;4, 5&gt;;expected to 9</span><br></pre></td></tr></table></figure></div>
</div></div><div class="post-main post-comment"><div id="giscus_thread"></div><script src="https://giscus.app/client.js"
        data-repo="angelise7/blog-comments"
        data-repo-id="R_kgDOPQr6lw"
        data-category=""
        data-category-id=""
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script></div></article><link rel="stylesheet" type="text/css" href="/css/third-party/font-awesome/4.5.0/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/lato-font/3.0.0/css/lato-font.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.css"><script src="/js/third-party/jquery/2.0.3/jquery.min.js"></script><script src="/js/third-party/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>